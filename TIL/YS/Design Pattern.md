# 1. 디자인 패턴

> 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있또록 하나의 ‘규약’ 형태로 만들어 놓은 것
> 

## 1) 싱글톤 패턴

> 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴 → 데이터베이스 연결 모듈에 많이 사용
> 

**장점**

- 인스턴스를 생성할 때 드는 비용이 줄어든다.
- 사용하기 쉽고 굉장히 실용적이다.

**단점**

- 의존성이 높아진다.
- TDD에서 걸림돌이 됨.
    - TDD에서 단위테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 한다.
    - 싱글톤 패턴에서는 ‘독립적인’ 인스턴스를 만들기 어렵다.
- 모듈 간의 결합을 강하게 만들 수 있다.
    
    ➡️ 의존성 주입을 통해 해결
    

### 의존성 주입(DI, Dependancy Injection)

> 📌 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다.
📌 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 한다.
> 
- 메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기 보다는 중간에 의존성 주입자(dependancy injector)가 이 부분을 가로채 메인 모듈이 간접적으로 의존성 주입
- 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 된다 ➡️ ‘디커플링 된다’

**장점**

- 모듈을 쉽게 교체 할 수 있는 구조
- 테스팅하기 쉽다.
- 마이그레이션 하기 수월하다.
- 애플리케이션 의존성 방향이 일관된다.
- 애플리케이션 쉽게 추론 가능
- 모듈 간의 관계들이 명확해진다.

**단점**

- 클래스 수가 늘어나 복잡성 증가
    
    ➡️ 약간의 런타임 페널티가 생김
    

---

## 2) 팩토리 패턴

> 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴
> 

- 느슨한 결합을 가지며 상위 클래스에서는 더 많은 유연성을 갖게 된다.
- 코드 리팩터링 시 한 곳만 고칠 수 있게 되어 유지 보수성이 증가E한다.

### Enum

> 상수의 집합을 정의할 때 사용되는 타입.
상수나 메서드 등을 집어넣어서 관리하며 코드를 리팩터링할 때 해당 집합에 관한 로직 수정 시 이 부분만 수정하면 되므로 코드 리팩터링 시 강점이 생긴다.
> 

---

## 3) 전략 패턴/정책 패턴

> 객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주며서 상호 교체가 가능하게 만드는 패턴
> 

## 4) 옵저버 패턴

> 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
> 

- 이벤트 기반 시스템에 사용
- MVC(Model-View-Controller) 패턴에 사용
    - Model 변경 → update() 메서드 → 옵저버인 View에 알려줌 → Controller 작동